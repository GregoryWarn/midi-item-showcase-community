{
  "name": "Poisoner",
  "type": "feat",
  "system": {
    "description": {
      "value": "<h2><span style=\"font-family:Signika, sans-serif\">Made by WurstKorn</span></h2><h3 style=\"box-sizing:border-box;user-select:text;margin:0px 0px 0.5rem;padding:0px;font-weight:normal;font-size:1.25em;border-bottom:none;color:rgb(25, 24, 19);font-family:Signika, sans-serif;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;letter-spacing:normal;orphans:2;text-align:start;text-indent:0px;text-transform:none;white-space:normal;widows:2;word-spacing:0px;-webkit-text-stroke-width:0px;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial\"><span style=\"font-family:Signika, sans-serif\">Requires:</span></h3><ul style=\"box-sizing:border-box;user-select:text;margin:0.5em 0px;padding:0px 0px 0px 1.5em;color:rgb(25, 24, 19);font-family:Signika, sans-serif;font-size:13px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0px;text-transform:none;white-space:normal;widows:2;word-spacing:0px;-webkit-text-stroke-width:0px;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial\"><li style=\"box-sizing:border-box;user-select:text\"><p style=\"box-sizing:border-box;user-select:text;margin:0.5em 0px;margin-block-end:0px\"><span style=\"font-family:Signika, sans-serif\">Times-Up</span></p></li><li style=\"box-sizing:border-box;user-select:text\"><p><span style=\"font-family:Signika, sans-serif\">Warpgate</span></p><p style=\"box-sizing:border-box;user-select:text;margin:0.5em 0px;color:rgb(25, 24, 19);font-family:Signika, sans-serif;font-size:13px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-indent:0px;text-transform:none;white-space:normal;widows:2;word-spacing:0px;-webkit-text-stroke-width:0px;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial;text-align:start\"></p></li></ul><p style=\"box-sizing:border-box;user-select:text;margin:0.5em 0px;color:rgb(25, 24, 19);font-family:Signika, sans-serif;font-size:13px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-indent:0px;text-transform:none;white-space:normal;widows:2;word-spacing:0px;-webkit-text-stroke-width:0px;text-decoration-thickness:initial;text-decoration-style:initial;text-decoration-color:initial;text-align:start\"><span style=\"font-family:'gg sans', 'Noto Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif\">Check that your ammunition has a damage type (e.g. piercing), it doesn't need a damage value.</span></p>",
      "chat": "You ignore resistance to poison damage, can apply poison to a weapon or piece of ammunition as a bonus action, gain proficiency with poisoner's kit and can create a special poison.",
      "unidentified": ""
    },
    "source": {
      "custom": ""
    },
    "activation": {
      "type": "hour",
      "cost": 1,
      "condition": ""
    },
    "duration": {
      "value": "",
      "units": ""
    },
    "cover": null,
    "crewed": false,
    "target": {
      "value": null,
      "width": null,
      "units": "",
      "type": "self",
      "prompt": true
    },
    "range": {
      "value": null,
      "long": null,
      "units": ""
    },
    "uses": {
      "value": null,
      "max": "",
      "per": null,
      "recovery": "",
      "prompt": true
    },
    "consume": {
      "type": "",
      "target": "currency.gp",
      "amount": 50,
      "scale": false
    },
    "ability": "",
    "actionType": "util",
    "attackBonus": "",
    "chatFlavor": "",
    "critical": {
      "threshold": null,
      "damage": ""
    },
    "damage": {
      "parts": [],
      "versatile": ""
    },
    "formula": "",
    "save": {
      "ability": "",
      "dc": null,
      "scaling": "spell"
    },
    "type": {
      "value": "feat",
      "subtype": ""
    },
    "requirements": "",
    "recharge": {
      "value": null,
      "charged": false
    }
  },
  "flags": {
    "ddbimporter": {
      "featId": 452849,
      "version": "3.6.0",
      "prerequisites": []
    },
    "obsidian": {
      "source": {
        "type": "feat"
      }
    },
    "core": {},
    "magicitems": {
      "enabled": false,
      "equipped": false,
      "attuned": false,
      "charges": "0",
      "chargeType": "c1",
      "destroy": false,
      "destroyFlavorText": "reaches 0 charges: it crumbles into ashes and is destroyed.",
      "rechargeable": false,
      "recharge": "0",
      "rechargeType": "t1",
      "rechargeUnit": "r1",
      "sorting": "l"
    },
    "dae": {
      "macro": {
        "name": "Poisoner",
        "img": "icons/skills/melee/strike-scythe-fire-green.webp",
        "type": "script",
        "scope": "global",
        "command": "",
        "author": "B2BBHntfpytXE8DP",
        "ownership": {
          "default": 3
        },
        "_id": null,
        "folder": null,
        "sort": 0,
        "flags": {},
        "_stats": {
          "systemId": null,
          "systemVersion": null,
          "coreVersion": null,
          "createdTime": null,
          "modifiedTime": null,
          "lastModifiedBy": null
        }
      }
    },
    "itemacro": {
      "macro": {
        "command": "if (args[0].tag === \"OnUse\" && args[0].macroPass === \"postActiveEffects\") {\n\nif (!actor.items.getName('Poisoner\\'s Kit')){\nui.notifications.warn('You need the Poisoner\\'s Kit to create Potent Poison');\nreturn;\n};\nvar gold = actor.system.currency.gp;\nif (gold < 50){\nui.notifications.warn('You need at least 50gp to create Potent Poison. You have: '+gold+'gp.');\nreturn;\n};\n\nconst potentPoisonItemData = await getPotentPoisonItemData();\n  let potentPoisonItem = structuredClone(new CONFIG.Item.documentClass(potentPoisonItemData, { parent: actor, temporary: false}));\n\ngold = gold-50;\nquantity = actor.system.attributes.prof;\n\n\nif (!!actor.items.getName(potentPoisonItem.name)){\nquantity += actor.items.getName(potentPoisonItem.name).system.quantity;\n}\npotentPoisonItem.system.quantity = quantity;\n \n  let updates = {\n\t'actor':{'system': {'currency':{'gp':gold}}},\t\n        'embedded': {\n            'Item': {\n                [potentPoisonItem.name]: potentPoisonItem,\n            },\n        },\n    };\n\n    let options = {\n        'permanent': true,\n        'name': potentPoisonItem.name,\n        'description': potentPoisonItem.name,\n    };\nawait warpgate.mutate(workflow.token.document, updates, {}, options);\n\nreturn; \n};\n\nif (args[0].tag === \"OnUse\" && args[0].macroPass === \"preDamageRoll\") {\n  const macroData = args[0];\n\n let effectData = {\n        'label': 'Poisoner',\n        'icon': 'icons/skills/melee/strike-scythe-fire-green.webp',\n        'origin': macroData.sourceItemUuid,\n        'duration': {\n            'turns': 1\n        },\n         changes: [\n      {\n       key: 'system.traits.dv.value',\n            mode: 0,\n            value: 'poison',\n            priority: 20\n      }],\n        'transfer': true,\nflags: {\n      dae: {\n        specialDuration: [\"isDamaged\"],\n      },\n    },\n    }\n\nfor (let i = 0; i < macroData.hitTargetUuids.length; i++){\n\tconst target = fromUuidSync(macroData.hitTargetUuids[i]);\n\tremoveDR(target.actor, effectData)\n\t}\n}\n\n\n\nasync function removeDR(actor, effectData){\nif (actor.system.traits['dr'].value.has('poison')){\n await MidiQOL.socket().executeAsGM('createEffects',{actorUuid:actor.uuid, effects: [effectData]})\n}\n}\n\n\nasync function getPotentPoisonItemData() {\n \n  return {\n  \"name\": \"Potent Poison, (vial) (Poisoner)\",\n  \"type\": \"consumable\",\n  \"img\": \"icons/consumables/potions/potion-tube-corked-bubbling-green.webp\",\n  \"system\": {\n    \"description\": {\n      \"value\": \"<p>Once applied to a weapon or piece of ammunition, the poison retains its potency for 1 minute or until you hit with the weapon or ammunition. When a creature takes damage from the coated weapon or ammunition, that creature must succeed on a DC 14 Constitution saving throw or take 2d8 poison damage and become poisoned until the end of your next turn.</p>\",\n      \"chat\": \"\",\n      \"unidentified\": \"Gear\"\n    },\n    \"quantity\": 1,\n    \"weight\": 0.05,\n    \"price\": {\n      \"value\": 0,\n      \"denomination\": \"gp\"\n    },\n    \"attunement\": 0,\n    \"equipped\": false,\n    \"rarity\": \"\",\n    \"identified\": true,\n    \"activation\": {\n      \"type\": \"bonus\",\n      \"cost\": 1,\n      \"condition\": \"\"\n    },\n    \"duration\": {\n      \"value\": \"1\",\n      \"units\": \"minute\"\n    },\n    \"cover\": null,\n    \"crewed\": false,\n    \"target\": {\n      \"value\": null,\n      \"width\": null,\n      \"units\": \"\",\n      \"type\": \"self\",\n      \"prompt\": true\n    },\n    \"range\": {\n      \"value\": null,\n      \"long\": null,\n      \"units\": \"\"\n    },\n    \"uses\": {\n      \"value\": 1,\n      \"max\": \"1\",\n      \"per\": \"charges\",\n      \"recovery\": \"\",\n      \"autoDestroy\": true,\n      \"prompt\": true\n    },\n    \"ability\": \"\",\n    \"actionType\": \"other\",\n    \"attackBonus\": \"\",\n    \"chatFlavor\": \"\",\n    \"critical\": {\n      \"threshold\": null,\n      \"damage\": \"\"\n    },\n    \"damage\": {\n      \"parts\": [],\n      \"versatile\": \"\"\n    },\n    \"formula\": \"\",\n    \"save\": {\n      \"ability\": \"\",\n      \"dc\": 14,\n      \"scaling\": \"flat\"\n    },\n    \"consumableType\": \"poison\",\n    \"properties\": {}\n  },\n  \"effects\": [\n    ],\n  \"folder\": null,\n  \"flags\": {\n    \"ddbimporter\": {\n      \"dndbeyond\": {\n        \"type\": \"Poison\",\n        \"isConsumable\": false,\n        \"isContainer\": false,\n        \"isCustomItem\": false,\n        \"isHomebrew\": false,\n        \"isMonkWeapon\": false,\n        \"isPack\": false,\n        \"levelInfusionGranted\": null,\n        \"tags\": [\n          \"Damage\",\n          \"Utility\",\n          \"Combat\",\n          \"Consumable\"\n        ],\n        \"sources\": [\n          {\n            \"sourceId\": 1,\n            \"pageNumber\": null,\n            \"sourceType\": 2\n          },\n          {\n            \"sourceId\": 2,\n            \"pageNumber\": null,\n            \"sourceType\": 1\n          }\n        ],\n        \"stackable\": true\n      },\n      \"id\": 0,\n      \"entityTypeId\": 0,\n      \"definitionEntityTypeId\": 2103445194,\n      \"definitionId\": 68,\n      \"originalName\": \"Poison, Basic (vial)\",\n      \"version\": \"3.4.38\"\n    },\n    \"magicitems\": {\n      \"enabled\": false,\n      \"equipped\": false,\n      \"attuned\": false,\n      \"charges\": \"0\",\n      \"chargeType\": \"c1\",\n      \"destroy\": false,\n      \"destroyFlavorText\": \"reaches 0 charges: it crumbles into ashes and is destroyed.\",\n      \"rechargeable\": false,\n      \"recharge\": \"0\",\n      \"rechargeType\": \"t1\",\n      \"rechargeUnit\": \"r1\",\n      \"sorting\": \"l\"\n    },\n    \"cf\": {\n      \"id\": \"temp_4hpeel1ix1d\"\n    },\n    \"midi-qol\": {\n      \"onUseMacroName\": \"[postActiveEffects]ItemMacro\",\n      \"fumbleThreshold\": null,\n      \"effectActivation\": false,\n      \"onUseMacroParts\": {\n        \"items\": {\n          \"0\": {\n            \"macroName\": \"ItemMacro\",\n            \"option\": \"postActiveEffects\"\n          }\n        }\n      },\n      \"removeAttackDamageButtons\": \"default\"\n    },\n    \"rest-recovery\": {\n      \"data\": {\n        \"recovery\": {\n          \"enabled\": false\n        },\n        \"consumable\": {\n          \"enabled\": false,\n          \"dayWorth\": false\n        }\n      }\n    },\n    \"midiProperties\": {\n      \"nodam\": false,\n      \"fulldam\": false,\n      \"halfdam\": false,\n      \"autoFailFriendly\": false,\n      \"autoSaveFriendly\": false,\n      \"rollOther\": false,\n      \"critOther\": false,\n      \"offHandWeapon\": false,\n      \"magicdam\": false,\n      \"magiceffect\": false,\n      \"concentration\": false,\n      \"toggleEffect\": false,\n      \"ignoreTotalCover\": false,\n      \"noConcentrationCheck\": false,\n      \"confirmTargets\": \"never\"\n    },\n    \"core\": {},\n    \"itemacro\": {\n      \"macro\": {\n        \"name\": \"Potent Poison, (vial) (Poisoner)\",\n        \"type\": \"script\",\n        \"scope\": \"global\",\n        \"command\": \"// ##################################################################################################\\n// Read First!!!!\\n// Allow to choose a weapon or ammo on which the poison is applied. The chosen weapon or ammo applies\\n// the poison effect on a hit for the duration.\\n// v1.0.0\\n// Author: Elwin#1410\\n// Dependencies:\\n//  - DAE, item macro [off]\\n//  - Times Up\\n//  - MidiQOL \\\"on use\\\" item macro, [postActiveEffects]\\n//  - Warpgate (dialog and mutation)\\n//  - Ammo Tracker (optional)\\n//\\n// How to configure:\\n// The item details must be:\\n//   - Activation cost: 1 Action\\n//   - Target: Self\\n//   - Range: None\\n//   - Duration: 1 minutes (or adjust depending on poison duration)\\n//   - Limited Uses: 1 of 1 per Charges\\n//   - Destroy on empty: (checked)\\n//   - Action type: Utility\\n//   - No damage should be configured\\n//   - Save: only set the type of DC, flat and the fixed DC value, if not set, DC 10 will be used,\\n//           this is a hack to allow customization of the poison DC.\\n//   - On Use Macros:\\n//       ItemMacro | After Active Effects\\n//   - This item macro code must be added to the ItemMacro code of the \\\"Poison, XXX (vial)\\\" item.\\n// Usage:\\n// This item must be used to activate its effect. It applies a mutation that adds the poison effect on a hit\\n// on the selected weapon or ammunition.\\n//\\n// Description:\\n// In the \\\"off\\\" DAE macro call:\\n//   Reverts the warpgate mutation that added the poisoned effect.\\n// In the postActiveEffects phase (of the source item):\\n//   Prompts a dialog to choose the weapon or ammunition on which the poison will be applied.\\n//   The if the chosen weapon or ammunition item quantity does not match the allowed quantity (1 or 3),\\n//   A new item is created from the selected item with the allowed quantity and this quantity is removed\\n//   from the selected item. A mutation is applied to the selected item or the new item created\\n//   (when quantity does not match allowed quantity). This mutation changes the name and description,\\n//   sets an onUse [postActiveEffects] item macro and a special item macro to handle it and\\n//   adds an active effect with a macro.itemMacro change, this is used to be notified when the poison expires.\\n//   If Ammo Tracker is active and a new ammunition item was created, updates the Combat flag that\\n//   contains the module's ammunition tracking info.\\n// In the postActiveEffects phase (of the poisoned item):\\n//   On a hit, a temporary item to apply the poison effects is created and used with a MidiQOL.completeItemUse call.\\n//   If the poisoned item is a weapon, and it has uses, its uses are decremented, if there is no more\\n//   uses the poison active effect is deleted to force its expiration.\\n// ###################################################################################################\\n\\nconst DEFAULT_ITEM_NAME = \\\"Potent Poison, (vial) (Poisoner)\\\";\\nconst debug = true;\\nconst MUT_NAME_PREFIX = \\\"PoisonAppliedTo\\\";\\nconst AMMO_TRACKER_MOD = \\\"ammo-tracker-fvtt\\\";\\nconst DEFAULT_SAVE_ABILITY = \\\"con\\\";\\nconst DEFAULT_DAMAGE_FORMULA = \\\"2d8\\\";\\nconst DEFAULT_DAMAGE_TYPE = \\\"poison\\\";\\n\\n///////////////// BEGIN CUSTOMIZE THIS /////////////////////////////\\n// Change dependending on the allowed weapon types\\nconst ALLOWED_WEAPON_TYPES = [\\\"simpleM\\\", \\\"martialM\\\", \\\"simpleR\\\", \\\"martialR\\\"];\\n// Change dependending on the allowed weapon damage types: slashing, piercing, bludgeoning\\nconst ALLOWED_DMG_TYPES = [\\\"slashing\\\", \\\"piercing\\\", \\\"bludgeoning\\\"];\\n// Change depending on the number of ammunitions that can be covered by one dose.\\nconst MAX_AMMO = 3;\\n// Null if no max uses with a weapon for this poison, otherwise set a number of hits allowed.\\nconst MAX_WEAPON_HITS = 1;\\n///////////////// END CUSTOMIZE THIS /////////////////////////////\\n\\nconst dependencies = [\\\"dae\\\", \\\"times-up\\\", \\\"midi-qol\\\", \\\"warpgate\\\"];\\nif (!requirementsSatisfied(DEFAULT_ITEM_NAME, dependencies)) {\\n  return;\\n}\\n\\n/**\\n * If the requirements are met, returns true, false otherwise.\\n *\\n * @param {string} name - The name of the item for which to check the dependencies.\\n * @param {Array} dependencies - The array of module ids which are required.\\n *\\n * @returns {boolean} true if the requirements are met, false otherwise.\\n */\\nfunction requirementsSatisfied(name, dependencies) {\\n  let missingDep = false;\\n  dependencies.forEach((dep) => {\\n    if (!game.modules.get(dep)?.active) {\\n      const errorMsg = `${name}: ${dep} must be installed and active.`;\\n      ui.notifications.error(errorMsg);\\n      console.warn(errorMsg);\\n      missingDep = true;\\n    }\\n  });\\n  return !missingDep;\\n}\\n\\nif (debug) {\\n  console.warn(DEFAULT_ITEM_NAME, { phase: args[0].tag ? args[0].macroPass : args[0] }, arguments);\\n}\\n\\nif (args[0].tag === \\\"OnUse\\\" && args[0].macroPass === \\\"postActiveEffects\\\") \\n{\\n  // Called on poison vial item\\n  const weaponChoices = actor.itemTypes.weapon\\n    .filter((i) => ALLOWED_WEAPON_TYPES.includes(i.system?.weaponType) && !i.system?.properties?.amm)\\n    .concat(actor.itemTypes.consumable.filter((i) => i.system?.consumableType === \\\"ammo\\\"))\\n    .filter(\\n      (i) =>\\n        i.system?.damage?.parts?.some((part) => ALLOWED_DMG_TYPES.includes(part[1])) &&\\n        i.system?.quantity > 0 &&\\n        !i.getFlag(\\\"world\\\", \\\"appliedPoison.origin\\\")\\n    );\\n\\n  if (debug) {\\n    console.warn(`${DEFAULT_ITEM_NAME} | weaponChoices`, weaponChoices);\\n  }\\n\\n  const data = {\\n    buttons: weaponChoices.map((i) => ({\\n      label: i.name + (i.type === \\\"consumable\\\" ? `[${i.system.quantity}]` : \\\"\\\"),\\n      value: i.id,\\n    })),\\n    title: \\\"⚔️ Choose your Poisoned Weapon or Ammo:\\\",\\n  };\\n  const selectedWeaponId = await warpgate.buttonDialog(data, \\\"column\\\");\\n  if (!selectedWeaponId) {\\n    if (debug) {\\n      console.warn(`${DEFAULT_ITEM_NAME} | Weapon or ammo selection was cancelled.`);\\n    }\\n    return;\\n  }\\n  const selectedWeapon = workflow.actor.items.get(selectedWeaponId);\\n  let poisonedItem = selectedWeapon;\\n  const allowedQuantity = selectedWeapon.type === \\\"consumable\\\" ? Math.min(MAX_AMMO, selectedWeapon.system.quantity) : 1;\\n\\n  const poisonedName = CONFIG.DND5E.conditionTypes[\\\"poisoned\\\"];\\n  if (allowedQuantity !== selectedWeapon.system.quantity) {\\n    // Split item with allowed quantity\\n    weaponData = selectedWeapon.toObject();\\n    delete weaponData._id;\\n    weaponData.system.quantity = allowedQuantity;\\n    await actor.updateEmbeddedDocuments(\\\"Item\\\", [\\n      {\\n        _id: selectedWeapon.id,\\n        [\\\"system.quantity\\\"]: selectedWeapon.system.quantity - allowedQuantity,\\n      },\\n    ]);\\n    const [newItem] = await actor.createEmbeddedDocuments(\\\"Item\\\", [weaponData]);\\n    poisonedItem = newItem;\\n  }\\n\\n  // Get Poison Effect Item UUID if defined From a special effect\\n  const poisonEffectItemUuid = rolledItem.effects\\n    ?.getName(\\\"PoisonEffect\\\")\\n    ?.changes.find((c) => c.key === \\\"flags.world.poisonEffectItemUuid\\\")?.value;\\n  const poisonEffectItem = await fromUuid(poisonEffectItemUuid);\\n  let poisonEffectItemData = undefined;\\n  if (poisonEffectItem) {\\n    if (poisonEffectItem instanceof CONFIG.Item.documentClass) {\\n      poisonEffectItemData = poisonEffectItem.toObject();\\n    } else {\\n      console.warn(`${DEFAULT_ITEM_NAME} | The specified UUID is not an item`, { poisonedItem });\\n    }\\n  }\\n  const mutName = `${MUT_NAME_PREFIX}-${poisonedItem.id}`;\\n  const macroName = `${mutName}-by-${actor.uuid}`;\\n  const newItemName = `${selectedWeapon.name} [${poisonedName}]`;\\n  const appliedPoisonValue = {\\n    origin: rolledItem.uuid,\\n    name: rolledItem.name,\\n    img: rolledItem.img,\\n    saveDC: rolledItem.system?.save?.dc ?? 14,\\n    poisonEffectItemData,\\n  };\\n  let onUseMacroNameValue = selectedWeapon.getFlag(\\\"midi-qol\\\", \\\"onUseMacroName\\\");\\n  if (onUseMacroNameValue) {\\n    onUseMacroNameValue += `,[postActiveEffects]${macroName}`;\\n  } else {\\n    onUseMacroNameValue = `[postActiveEffects]${macroName}`;\\n  }\\n  const updates = {\\n    embedded: {\\n      Item: {\\n        [poisonedItem.id]: {\\n          name: newItemName,\\n          system: {\\n            description: {\\n              value: `<p><em>${poisonedName} by ${rolledItem.name}</em></p>\\\\n${\\n                selectedWeapon.system?.description?.value ?? \\\"\\\"\\n              }`,\\n            },\\n          },\\n          flags: {\\n            world: { appliedPoison: appliedPoisonValue },\\n            // Flag to handle the poison effect after an attack that hit\\n            \\\"midi-qol\\\": { onUseMacroName: onUseMacroNameValue },\\n          },\\n        },\\n      },\\n    },\\n  };\\n  if (poisonedItem.type === \\\"weapon\\\" && MAX_WEAPON_HITS) {\\n    appliedPoisonValue.uses = MAX_WEAPON_HITS;\\n  }\\n\\n  const options = {\\n    name: mutName,\\n    comparisonKeys: { Item: \\\"id\\\" },\\n  };\\n\\n  // Remove previous applied AE if it exists (needs to be done before mutating otherwise the [off] callback reverts the mutation)\\n  await workflow.actor.effects?.getName(mutName)?.delete();\\n\\n  if (!!warpgate.mutationStack(workflow.token.document).getName(mutName)) {\\n    await warpgate.revert(workflow.token.document, mutName);\\n  }\\n\\n  await warpgate.mutate(workflow.token.document, updates, {}, options);\\n  // Create macro to handle poison effect (this is done to allow existing item macro to be untouched),\\n  // but delete if it already exists.\\n  await game.macros.getName(macroName)?.delete();\\n  await Macro.createDocuments([\\n    {\\n      name: macroName,\\n      type: \\\"script\\\",\\n      scope: \\\"global\\\",\\n      command: getPoisonedItemMacro(),\\n    },\\n  ]);\\n\\n  let effectDuration = { type: \\\"seconds\\\", seconds: 60 };\\n  if (rolledItem.system?.duration?.value && rolledItem.system?.duration?.units) {\\n    effectDuration = DAE.convertDuration(rolledItem.system.duration);\\n  }\\n  const effectData = {\\n    changes: [\\n      // Flag to handle end of effect\\n      {\\n        key: \\\"macro.execute\\\",\\n        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,\\n        value: macroName,\\n        priority: 20,\\n      },\\n    ],\\n    origin: poisonedItem.uuid, //flag the effect as associated to the poisoned item\\n    disabled: false,\\n    duration: effectDuration,\\n    icon: rolledItem.img,\\n    name: mutName,\\n  };\\n  await workflow.actor.createEmbeddedDocuments(\\\"ActiveEffect\\\", [effectData]);\\n\\n  // Make the proper adjustements for Ammo Tracker\\n  if (\\n    game.modules.get(AMMO_TRACKER_MOD)?.active &&\\n    selectedWeapon.type === \\\"consumable\\\" &&\\n    poisonedItem.id !== selectedWeaponId &&\\n    workflow.actor.type === \\\"character\\\"\\n  ) {\\n    for (let combat of game.combats) {\\n      const actorAmmoAttr = `projectileData.${workflow.actor.id}`;\\n      const actorAmmo = combat.getFlag(AMMO_TRACKER_MOD, actorAmmoAttr);\\n      if (actorAmmo?.[selectedWeaponId]) {\\n        const updatedActorAmmo = deepClone(actorAmmo);\\n        updatedActorAmmo[selectedWeaponId] = updatedActorAmmo[selectedWeaponId] - allowedQuantity;\\n        updatedActorAmmo[poisonedItem.id] = allowedQuantity;\\n        await combat.setFlag(AMMO_TRACKER_MOD, actorAmmoAttr, updatedActorAmmo);\\n      }\\n    }\\n  }\\n} \\n\\n/**\\n * Returns the item macro to handle the poisoned item effect.\\n *\\n * @returns {String} the item macro to handle the poisoned item effect.\\n */\\nfunction getPoisonedItemMacro() {\\n  return `\\nconst DEFAULT_ITEM_NAME = \\\"${DEFAULT_ITEM_NAME}\\\";\\nconst debug = ${debug};\\n\\nconst MUT_NAME_PREFIX = \\\"${MUT_NAME_PREFIX}\\\";\\n\\nconst DEFAULT_SAVE_ABILITY = \\\"${DEFAULT_SAVE_ABILITY}\\\";\\nconst DEFAULT_DAMAGE_FORMULA = \\\"${DEFAULT_DAMAGE_FORMULA}\\\";\\nconst DEFAULT_DAMAGE_TYPE = \\\"${DEFAULT_DAMAGE_TYPE}\\\";\\n\\nif (debug) {\\n  console.warn(DEFAULT_ITEM_NAME, { phase: args[0].tag ? args[0].macroPass : args[0] }, arguments);\\n}\\n\\nif (args[0].tag === \\\"OnUse\\\" && args[0].macroPass === \\\"postActiveEffects\\\") {\\n  const macroData = args[0];\\n  if (workflow.hitTargets.size === 0) {\\n    return;\\n  }\\n  await handlePoisonPostActiveEffects(macroData, workflow, rolledItem);\\n} else if (args[0] === \\\"off\\\") {\\n  const sourceToken = canvas.tokens.get(lastArgValue.tokenId);\\n  const sourceItem = fromUuidSync(lastArgValue.origin);\\n  const mutName = \\\\`\\\\${MUT_NAME_PREFIX}-\\\\${sourceItem?.id}\\\\`;\\n  await warpgate.revert(sourceToken.document, mutName);\\n  // Make sure that if other mutations were added after this one, \\n  // we remove poisoned from the name\\n  const poisonedName = \\\\` [\\\\${CONFIG.DND5E.conditionTypes[\\\"poisoned\\\"]}]\\\\`;\\n  if (sourceItem.name.includes(poisonedName)) {\\n    const newName = sourceItem.name.replace(poisonedName, \\\"\\\");\\n    await sourceItem.update({name: newName});\\n  }\\n\\n  // Note: warpgate does not remove added flags, it nulls them, unset them is the item was not an added one\\n  if (sourceItem) {\\n    await sourceItem.unsetFlag(\\\"world\\\", \\\"appliedPoison\\\");\\n  }\\n  \\n  // Delete created macro.\\n  const macroName = \\\\`\\\\${mutName}-by-\\\\${sourceToken.actor.uuid}\\\\`;\\n  await game.macros.getName(macroName)?.delete();\\n}\\n\\n${handlePoisonPostActiveEffects.toString()}\\n\\n${getPoisonEffectItemData.toString()}\\n\\n`;\\n}\\n\\n/**\\n * Handles the poison effect when an attack hit with the poisoned weapon or the weapon that used a poisoned ammunition.\\n * A temporary item is created to apply the damage on a failed saved and passed to MidiQOL.completeItemUse.\\n *\\n * @param {object} macroData the midi macro data.\\n * @param {MidiQOL.Workflow} poisonAttackWorkflow the current midi workflow.\\n * @param {Item5E} item the used item\\n * @returns {void}\\n */\\nasync function handlePoisonPostActiveEffects(macroData, poisonAttackWorkflow, item) {\\n  const appliedPoison = item.getFlag(\\\"world\\\", \\\"appliedPoison\\\");\\n  if (!appliedPoison) {\\n    console.error(`${DEFAULT_ITEM_NAME} | Missing appliedPoison flag on poisoned weapon or ammo.`);\\n    return;\\n  }\\n  if (poisonAttackWorkflow.item?.uuid !== item.uuid && poisonAttackWorkflow.ammo?.uuid !== item.uuid) {\\n    if (debug) {\\n      console.warn(`${DEFAULT_ITEM_NAME} | Skip, called from a workflow on another item than the poisoned one.`);\\n    }\\n    return;\\n  }\\n\\n  // Call complete item use with temp item on first hit target\\n  const poisonItemData = await getPoisonEffectItemData(appliedPoison);\\n  const poisonItem = new CONFIG.Item.documentClass(poisonItemData, { parent: workflow.actor, temporary: true });\\n\\n  const options = {\\n    targetUuids: [macroData.hitTargetUuids[0]],\\n  };\\n  try {\\n    await MidiQOL.completeItemUse(poisonItem, {}, options);\\n  } finally {\\n    // When the poisoned item is a weapon and has uses, update uses\\n    if (item.type === \\\"weapon\\\" && appliedPoison.uses) {\\n      const newUses = appliedPoison.uses - 1;\\n      if (newUses > 0) {\\n        await item.setFlag(\\\"world\\\", \\\"appliedPoison.uses\\\", newUses);\\n      } else {\\n        // The maximum uses has been reached, the poisoned weapon effect expires...\\n        const mutName = `${MUT_NAME_PREFIX}-${item.id}`;\\n        await poisonAttackWorkflow.actor.effects.getName(mutName)?.delete();\\n      }\\n    }\\n  }\\n}\\n\\n/**\\n * Returns the temporary item data for the poison effect.\\n * @param {object} appliedPoison the basic information on the poison that was applied.\\n * @returns {object} a temporary item data for the poison effect.\\n */\\nasync function getPoisonEffectItemData(appliedPoison) {\\n \\n  // Use default basic poison\\n  return {\\n    type: \\\"consumable\\\",\\n    name: `Poison - Effect`,\\n    img: appliedPoison.img,\\n    system: {\\n      consumableType: \\\"poison\\\",\\n      actionType: \\\"other\\\",\\n      damage: { parts: [[DEFAULT_DAMAGE_FORMULA, DEFAULT_DAMAGE_TYPE]] },\\n      save: { ability: DEFAULT_SAVE_ABILITY, dc: appliedPoison.saveDC, scaling: \\\"flat\\\" },\\n    },\\n\\\"effects\\\": [\\n    {\\n      \\\"changes\\\": [\\n        {\\n          \\\"key\\\": \\\"flags.midi-qol.disadvantage.attack.all\\\",\\n          \\\"mode\\\": 0,\\n          \\\"value\\\": \\\"1\\\",\\n          \\\"priority\\\": 0\\n        },\\n        {\\n          \\\"key\\\": \\\"flags.midi-qol.disadvantage.ability.check.all\\\",\\n          \\\"mode\\\": 0,\\n          \\\"value\\\": \\\"1\\\",\\n          \\\"priority\\\": 0\\n        }\\n      ],\\n      \\\"description\\\": \\\"<p>- A poisoned creature has disadvantage on attack rolls and ability checks.</p>\\\",\\n      \\\"disabled\\\": false,\\n      \\\"duration\\\": {\\n        \\\"rounds\\\": 2,\\n        \\\"seconds\\\": null,\\n        \\\"turns\\\": null,\\n        \\\"startTime\\\": null,\\n        \\\"combat\\\": null,\\n        \\\"startRound\\\": null,\\n        \\\"startTurn\\\": null\\n      },\\n      \\\"flags\\\": {\\n        \\\"dfreds-convenient-effects\\\": {\\n          \\\"isConvenient\\\": true,\\n          \\\"isDynamic\\\": false,\\n          \\\"isViewable\\\": true,\\n          \\\"nestedEffects\\\": [],\\n          \\\"subEffects\\\": []\\n        },\\n        \\\"dae\\\": {\\n          \\\"stackable\\\": \\\"noneName\\\",\\n          \\\"specialDuration\\\": [\\n            \\\"turnEndSource\\\"\\n          ],\\n          \\\"transfer\\\": false,\\n          \\\"disableIncapacitated\\\": false,\\n          \\\"selfTarget\\\": false,\\n          \\\"selfTargetAlways\\\": false,\\n          \\\"dontApply\\\": false,\\n          \\\"showIcon\\\": false,\\n          \\\"durationExpression\\\": \\\"\\\",\\n          \\\"macroRepeat\\\": \\\"none\\\"\\n        },\\n        \\\"times-up\\\": {\\n          \\\"isPassive\\\": false\\n        },\\n        \\\"ActiveAuras\\\": {\\n          \\\"isAura\\\": false,\\n          \\\"aura\\\": \\\"None\\\",\\n          \\\"nameOverride\\\": \\\"\\\",\\n          \\\"radius\\\": \\\"\\\",\\n          \\\"alignment\\\": \\\"\\\",\\n          \\\"type\\\": \\\"\\\",\\n          \\\"customCheck\\\": \\\"\\\",\\n          \\\"ignoreSelf\\\": false,\\n          \\\"height\\\": false,\\n          \\\"hidden\\\": false,\\n          \\\"displayTemp\\\": false,\\n          \\\"hostile\\\": false,\\n          \\\"onlyOnce\\\": false,\\n          \\\"wallsBlock\\\": \\\"system\\\"\\n        }\\n      },\\n      \\\"icon\\\": \\\"modules/dfreds-convenient-effects/images/poisoned.svg\\\",\\n      \\\"name\\\": \\\"Poisoned\\\",\\n      \\\"origin\\\": \\\"\\\",\\n      \\\"tint\\\": null,\\n      \\\"transfer\\\": false,\\n      \\\"statuses\\\": [\\n        \\\"Convenient Effect: Poisoned\\\",\\n        \\\"poison\\\"\\n      ],\\n      \\\"_id\\\": \\\"okjAiINyCoY5M8Ax\\\"\\n    }\\n  ],\\n    flags: { midiProperties: { nodam: true } },\\n  };\\n}\",\n        \"author\": \"RDUD9VahrEsIwEDB\",\n        \"_id\": null,\n        \"img\": \"icons/consumables/potions/potion-tube-corked-bubbling-green.webp\",\n        \"folder\": null,\n        \"sort\": 0,\n        \"ownership\": {\n          \"default\": 3\n        },\n        \"flags\": {},\n        \"_stats\": {\n          \"systemId\": null,\n          \"systemVersion\": null,\n          \"coreVersion\": null,\n          \"createdTime\": null,\n          \"modifiedTime\": null,\n          \"lastModifiedBy\": null\n        }\n      }\n    },\n    \"dae\": {\n      \"macro\": {\n        \"name\": \"Potent Poison, (vial) (Poisoner)\",\n        \"img\": \"icons/consumables/potions/potion-tube-corked-bubbling-green.webp\",\n        \"type\": \"script\",\n        \"scope\": \"global\",\n        \"command\": \"// ##################################################################################################\\n// Read First!!!!\\n// Allow to choose a weapon or ammo on which the poison is applied. The chosen weapon or ammo applies\\n// the poison effect on a hit for the duration.\\n// v1.0.0\\n// Author: Elwin#1410\\n// Dependencies:\\n//  - DAE, item macro [off]\\n//  - Times Up\\n//  - MidiQOL \\\"on use\\\" item macro, [postActiveEffects]\\n//  - Warpgate (dialog and mutation)\\n//  - Ammo Tracker (optional)\\n//\\n// How to configure:\\n// The item details must be:\\n//   - Activation cost: 1 Action\\n//   - Target: Self\\n//   - Range: None\\n//   - Duration: 1 minutes (or adjust depending on poison duration)\\n//   - Limited Uses: 1 of 1 per Charges\\n//   - Destroy on empty: (checked)\\n//   - Action type: Utility\\n//   - No damage should be configured\\n//   - Save: only set the type of DC, flat and the fixed DC value, if not set, DC 10 will be used,\\n//           this is a hack to allow customization of the poison DC.\\n//   - On Use Macros:\\n//       ItemMacro | After Active Effects\\n//   - This item macro code must be added to the ItemMacro code of the \\\"Poison, XXX (vial)\\\" item.\\n// Usage:\\n// This item must be used to activate its effect. It applies a mutation that adds the poison effect on a hit\\n// on the selected weapon or ammunition.\\n//\\n// Description:\\n// In the \\\"off\\\" DAE macro call:\\n//   Reverts the warpgate mutation that added the poisoned effect.\\n// In the postActiveEffects phase (of the source item):\\n//   Prompts a dialog to choose the weapon or ammunition on which the poison will be applied.\\n//   The if the chosen weapon or ammunition item quantity does not match the allowed quantity (1 or 3),\\n//   A new item is created from the selected item with the allowed quantity and this quantity is removed\\n//   from the selected item. A mutation is applied to the selected item or the new item created\\n//   (when quantity does not match allowed quantity). This mutation changes the name and description,\\n//   sets an onUse [postActiveEffects] item macro and a special item macro to handle it and\\n//   adds an active effect with a macro.itemMacro change, this is used to be notified when the poison expires.\\n//   If Ammo Tracker is active and a new ammunition item was created, updates the Combat flag that\\n//   contains the module's ammunition tracking info.\\n// In the postActiveEffects phase (of the poisoned item):\\n//   On a hit, a temporary item to apply the poison effects is created and used with a MidiQOL.completeItemUse call.\\n//   If the poisoned item is a weapon, and it has uses, its uses are decremented, if there is no more\\n//   uses the poison active effect is deleted to force its expiration.\\n// ###################################################################################################\\n\\nconst DEFAULT_ITEM_NAME = \\\"Potent Poison, (vial) (Poisoner)\\\";\\nconst debug = true;\\nconst MUT_NAME_PREFIX = \\\"PoisonAppliedTo\\\";\\nconst AMMO_TRACKER_MOD = \\\"ammo-tracker-fvtt\\\";\\nconst DEFAULT_SAVE_ABILITY = \\\"con\\\";\\nconst DEFAULT_DAMAGE_FORMULA = \\\"2d8\\\";\\nconst DEFAULT_DAMAGE_TYPE = \\\"poison\\\";\\n\\n///////////////// BEGIN CUSTOMIZE THIS /////////////////////////////\\n// Change dependending on the allowed weapon types\\nconst ALLOWED_WEAPON_TYPES = [\\\"simpleM\\\", \\\"martialM\\\", \\\"simpleR\\\", \\\"martialR\\\"];\\n// Change dependending on the allowed weapon damage types: slashing, piercing, bludgeoning\\nconst ALLOWED_DMG_TYPES = [\\\"slashing\\\", \\\"piercing\\\", \\\"bludgeoning\\\"];\\n// Change depending on the number of ammunitions that can be covered by one dose.\\nconst MAX_AMMO = 3;\\n// Null if no max uses with a weapon for this poison, otherwise set a number of hits allowed.\\nconst MAX_WEAPON_HITS = 1;\\n///////////////// END CUSTOMIZE THIS /////////////////////////////\\n\\nconst dependencies = [\\\"dae\\\", \\\"times-up\\\", \\\"midi-qol\\\", \\\"warpgate\\\"];\\nif (!requirementsSatisfied(DEFAULT_ITEM_NAME, dependencies)) {\\n  return;\\n}\\n\\n/**\\n * If the requirements are met, returns true, false otherwise.\\n *\\n * @param {string} name - The name of the item for which to check the dependencies.\\n * @param {Array} dependencies - The array of module ids which are required.\\n *\\n * @returns {boolean} true if the requirements are met, false otherwise.\\n */\\nfunction requirementsSatisfied(name, dependencies) {\\n  let missingDep = false;\\n  dependencies.forEach((dep) => {\\n    if (!game.modules.get(dep)?.active) {\\n      const errorMsg = `${name}: ${dep} must be installed and active.`;\\n      ui.notifications.error(errorMsg);\\n      console.warn(errorMsg);\\n      missingDep = true;\\n    }\\n  });\\n  return !missingDep;\\n}\\n\\nif (debug) {\\n  console.warn(DEFAULT_ITEM_NAME, { phase: args[0].tag ? args[0].macroPass : args[0] }, arguments);\\n}\\n\\nif (args[0].tag === \\\"OnUse\\\" && args[0].macroPass === \\\"postActiveEffects\\\") \\n{\\n  // Called on poison vial item\\n  const weaponChoices = actor.itemTypes.weapon\\n    .filter((i) => ALLOWED_WEAPON_TYPES.includes(i.system?.weaponType) && !i.system?.properties?.amm)\\n    .concat(actor.itemTypes.consumable.filter((i) => i.system?.consumableType === \\\"ammo\\\"))\\n    .filter(\\n      (i) =>\\n        i.system?.damage?.parts?.some((part) => ALLOWED_DMG_TYPES.includes(part[1])) &&\\n        i.system?.quantity > 0 &&\\n        !i.getFlag(\\\"world\\\", \\\"appliedPoison.origin\\\")\\n    );\\n\\n  if (debug) {\\n    console.warn(`${DEFAULT_ITEM_NAME} | weaponChoices`, weaponChoices);\\n  }\\n\\n  const data = {\\n    buttons: weaponChoices.map((i) => ({\\n      label: i.name + (i.type === \\\"consumable\\\" ? `[${i.system.quantity}]` : \\\"\\\"),\\n      value: i.id,\\n    })),\\n    title: \\\"⚔️ Choose your Poisoned Weapon or Ammo:\\\",\\n  };\\n  const selectedWeaponId = await warpgate.buttonDialog(data, \\\"column\\\");\\n  if (!selectedWeaponId) {\\n    if (debug) {\\n      console.warn(`${DEFAULT_ITEM_NAME} | Weapon or ammo selection was cancelled.`);\\n    }\\n    return;\\n  }\\n  const selectedWeapon = workflow.actor.items.get(selectedWeaponId);\\n  let poisonedItem = selectedWeapon;\\n  const allowedQuantity = selectedWeapon.type === \\\"consumable\\\" ? Math.min(MAX_AMMO, selectedWeapon.system.quantity) : 1;\\n\\n  const poisonedName = CONFIG.DND5E.conditionTypes[\\\"poisoned\\\"];\\n  if (allowedQuantity !== selectedWeapon.system.quantity) {\\n    // Split item with allowed quantity\\n    weaponData = selectedWeapon.toObject();\\n    delete weaponData._id;\\n    weaponData.system.quantity = allowedQuantity;\\n    await actor.updateEmbeddedDocuments(\\\"Item\\\", [\\n      {\\n        _id: selectedWeapon.id,\\n        [\\\"system.quantity\\\"]: selectedWeapon.system.quantity - allowedQuantity,\\n      },\\n    ]);\\n    const [newItem] = await actor.createEmbeddedDocuments(\\\"Item\\\", [weaponData]);\\n    poisonedItem = newItem;\\n  }\\n\\n  // Get Poison Effect Item UUID if defined From a special effect\\n  const poisonEffectItemUuid = rolledItem.effects\\n    ?.getName(\\\"PoisonEffect\\\")\\n    ?.changes.find((c) => c.key === \\\"flags.world.poisonEffectItemUuid\\\")?.value;\\n  const poisonEffectItem = await fromUuid(poisonEffectItemUuid);\\n  let poisonEffectItemData = undefined;\\n  if (poisonEffectItem) {\\n    if (poisonEffectItem instanceof CONFIG.Item.documentClass) {\\n      poisonEffectItemData = poisonEffectItem.toObject();\\n    } else {\\n      console.warn(`${DEFAULT_ITEM_NAME} | The specified UUID is not an item`, { poisonedItem });\\n    }\\n  }\\n  const mutName = `${MUT_NAME_PREFIX}-${poisonedItem.id}`;\\n  const macroName = `${mutName}-by-${actor.uuid}`;\\n  const newItemName = `${selectedWeapon.name} [${poisonedName}]`;\\n  const appliedPoisonValue = {\\n    origin: rolledItem.uuid,\\n    name: rolledItem.name,\\n    img: rolledItem.img,\\n    saveDC: rolledItem.system?.save?.dc ?? 14,\\n    poisonEffectItemData,\\n  };\\n  let onUseMacroNameValue = selectedWeapon.getFlag(\\\"midi-qol\\\", \\\"onUseMacroName\\\");\\n  if (onUseMacroNameValue) {\\n    onUseMacroNameValue += `,[postActiveEffects]${macroName}`;\\n  } else {\\n    onUseMacroNameValue = `[postActiveEffects]${macroName}`;\\n  }\\n  const updates = {\\n    embedded: {\\n      Item: {\\n        [poisonedItem.id]: {\\n          name: newItemName,\\n          system: {\\n            description: {\\n              value: `<p><em>${poisonedName} by ${rolledItem.name}</em></p>\\\\n${\\n                selectedWeapon.system?.description?.value ?? \\\"\\\"\\n              }`,\\n            },\\n          },\\n          flags: {\\n            world: { appliedPoison: appliedPoisonValue },\\n            // Flag to handle the poison effect after an attack that hit\\n            \\\"midi-qol\\\": { onUseMacroName: onUseMacroNameValue },\\n          },\\n        },\\n      },\\n    },\\n  };\\n  if (poisonedItem.type === \\\"weapon\\\" && MAX_WEAPON_HITS) {\\n    appliedPoisonValue.uses = MAX_WEAPON_HITS;\\n  }\\n\\n  const options = {\\n    name: mutName,\\n    comparisonKeys: { Item: \\\"id\\\" },\\n  };\\n\\n  // Remove previous applied AE if it exists (needs to be done before mutating otherwise the [off] callback reverts the mutation)\\n  await workflow.actor.effects?.getName(mutName)?.delete();\\n\\n  if (!!warpgate.mutationStack(workflow.token.document).getName(mutName)) {\\n    await warpgate.revert(workflow.token.document, mutName);\\n  }\\n\\n  await warpgate.mutate(workflow.token.document, updates, {}, options);\\n  // Create macro to handle poison effect (this is done to allow existing item macro to be untouched),\\n  // but delete if it already exists.\\n  await game.macros.getName(macroName)?.delete();\\n  await Macro.createDocuments([\\n    {\\n      name: macroName,\\n      type: \\\"script\\\",\\n      scope: \\\"global\\\",\\n      command: getPoisonedItemMacro(),\\n    },\\n  ]);\\n\\n  let effectDuration = { type: \\\"seconds\\\", seconds: 60 };\\n  if (rolledItem.system?.duration?.value && rolledItem.system?.duration?.units) {\\n    effectDuration = DAE.convertDuration(rolledItem.system.duration);\\n  }\\n  const effectData = {\\n    changes: [\\n      // Flag to handle end of effect\\n      {\\n        key: \\\"macro.execute\\\",\\n        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,\\n        value: macroName,\\n        priority: 20,\\n      },\\n    ],\\n    origin: poisonedItem.uuid, //flag the effect as associated to the poisoned item\\n    disabled: false,\\n    duration: effectDuration,\\n    icon: rolledItem.img,\\n    name: mutName,\\n  };\\n  await workflow.actor.createEmbeddedDocuments(\\\"ActiveEffect\\\", [effectData]);\\n\\n  // Make the proper adjustements for Ammo Tracker\\n  if (\\n    game.modules.get(AMMO_TRACKER_MOD)?.active &&\\n    selectedWeapon.type === \\\"consumable\\\" &&\\n    poisonedItem.id !== selectedWeaponId &&\\n    workflow.actor.type === \\\"character\\\"\\n  ) {\\n    for (let combat of game.combats) {\\n      const actorAmmoAttr = `projectileData.${workflow.actor.id}`;\\n      const actorAmmo = combat.getFlag(AMMO_TRACKER_MOD, actorAmmoAttr);\\n      if (actorAmmo?.[selectedWeaponId]) {\\n        const updatedActorAmmo = deepClone(actorAmmo);\\n        updatedActorAmmo[selectedWeaponId] = updatedActorAmmo[selectedWeaponId] - allowedQuantity;\\n        updatedActorAmmo[poisonedItem.id] = allowedQuantity;\\n        await combat.setFlag(AMMO_TRACKER_MOD, actorAmmoAttr, updatedActorAmmo);\\n      }\\n    }\\n  }\\n} \\n\\n/**\\n * Returns the item macro to handle the poisoned item effect.\\n *\\n * @returns {String} the item macro to handle the poisoned item effect.\\n */\\nfunction getPoisonedItemMacro() {\\n  return `\\nconst DEFAULT_ITEM_NAME = \\\"${DEFAULT_ITEM_NAME}\\\";\\nconst debug = ${debug};\\n\\nconst MUT_NAME_PREFIX = \\\"${MUT_NAME_PREFIX}\\\";\\n\\nconst DEFAULT_SAVE_ABILITY = \\\"${DEFAULT_SAVE_ABILITY}\\\";\\nconst DEFAULT_DAMAGE_FORMULA = \\\"${DEFAULT_DAMAGE_FORMULA}\\\";\\nconst DEFAULT_DAMAGE_TYPE = \\\"${DEFAULT_DAMAGE_TYPE}\\\";\\n\\nif (debug) {\\n  console.warn(DEFAULT_ITEM_NAME, { phase: args[0].tag ? args[0].macroPass : args[0] }, arguments);\\n}\\n\\nif (args[0].tag === \\\"OnUse\\\" && args[0].macroPass === \\\"postActiveEffects\\\") {\\n  const macroData = args[0];\\n  if (workflow.hitTargets.size === 0) {\\n    return;\\n  }\\n  await handlePoisonPostActiveEffects(macroData, workflow, rolledItem);\\n} else if (args[0] === \\\"off\\\") {\\n  const sourceToken = canvas.tokens.get(lastArgValue.tokenId);\\n  const sourceItem = fromUuidSync(lastArgValue.origin);\\n  const mutName = \\\\`\\\\${MUT_NAME_PREFIX}-\\\\${sourceItem?.id}\\\\`;\\n  await warpgate.revert(sourceToken.document, mutName);\\n  // Make sure that if other mutations were added after this one, \\n  // we remove poisoned from the name\\n  const poisonedName = \\\\` [\\\\${CONFIG.DND5E.conditionTypes[\\\"poisoned\\\"]}]\\\\`;\\n  if (sourceItem.name.includes(poisonedName)) {\\n    const newName = sourceItem.name.replace(poisonedName, \\\"\\\");\\n    await sourceItem.update({name: newName});\\n  }\\n\\n  // Note: warpgate does not remove added flags, it nulls them, unset them is the item was not an added one\\n  if (sourceItem) {\\n    await sourceItem.unsetFlag(\\\"world\\\", \\\"appliedPoison\\\");\\n  }\\n  \\n  // Delete created macro.\\n  const macroName = \\\\`\\\\${mutName}-by-\\\\${sourceToken.actor.uuid}\\\\`;\\n  await game.macros.getName(macroName)?.delete();\\n}\\n\\n${handlePoisonPostActiveEffects.toString()}\\n\\n${getPoisonEffectItemData.toString()}\\n\\n`;\\n}\\n\\n/**\\n * Handles the poison effect when an attack hit with the poisoned weapon or the weapon that used a poisoned ammunition.\\n * A temporary item is created to apply the damage on a failed saved and passed to MidiQOL.completeItemUse.\\n *\\n * @param {object} macroData the midi macro data.\\n * @param {MidiQOL.Workflow} poisonAttackWorkflow the current midi workflow.\\n * @param {Item5E} item the used item\\n * @returns {void}\\n */\\nasync function handlePoisonPostActiveEffects(macroData, poisonAttackWorkflow, item) {\\n  const appliedPoison = item.getFlag(\\\"world\\\", \\\"appliedPoison\\\");\\n  if (!appliedPoison) {\\n    console.error(`${DEFAULT_ITEM_NAME} | Missing appliedPoison flag on poisoned weapon or ammo.`);\\n    return;\\n  }\\n  if (poisonAttackWorkflow.item?.uuid !== item.uuid && poisonAttackWorkflow.ammo?.uuid !== item.uuid) {\\n    if (debug) {\\n      console.warn(`${DEFAULT_ITEM_NAME} | Skip, called from a workflow on another item than the poisoned one.`);\\n    }\\n    return;\\n  }\\n\\n  // Call complete item use with temp item on first hit target\\n  const poisonItemData = await getPoisonEffectItemData(appliedPoison);\\n  const poisonItem = new CONFIG.Item.documentClass(poisonItemData, { parent: workflow.actor, temporary: true });\\n\\n  const options = {\\n    targetUuids: [macroData.hitTargetUuids[0]],\\n  };\\n  try {\\n    await MidiQOL.completeItemUse(poisonItem, {}, options);\\n  } finally {\\n    // When the poisoned item is a weapon and has uses, update uses\\n    if (item.type === \\\"weapon\\\" && appliedPoison.uses) {\\n      const newUses = appliedPoison.uses - 1;\\n      if (newUses > 0) {\\n        await item.setFlag(\\\"world\\\", \\\"appliedPoison.uses\\\", newUses);\\n      } else {\\n        // The maximum uses has been reached, the poisoned weapon effect expires...\\n        const mutName = `${MUT_NAME_PREFIX}-${item.id}`;\\n        await poisonAttackWorkflow.actor.effects.getName(mutName)?.delete();\\n      }\\n    }\\n  }\\n}\\n\\n/**\\n * Returns the temporary item data for the poison effect.\\n * @param {object} appliedPoison the basic information on the poison that was applied.\\n * @returns {object} a temporary item data for the poison effect.\\n */\\nasync function getPoisonEffectItemData(appliedPoison) {\\n \\n  // Use default basic poison\\n  return {\\n    type: \\\"consumable\\\",\\n    name: `Poison - Effect`,\\n    img: appliedPoison.img,\\n    system: {\\n      consumableType: \\\"poison\\\",\\n      actionType: \\\"other\\\",\\n      damage: { parts: [[DEFAULT_DAMAGE_FORMULA, DEFAULT_DAMAGE_TYPE]] },\\n      save: { ability: DEFAULT_SAVE_ABILITY, dc: appliedPoison.saveDC, scaling: \\\"flat\\\" },\\n    },\\n\\\"effects\\\": [\\n    {\\n      \\\"changes\\\": [\\n        {\\n          \\\"key\\\": \\\"flags.midi-qol.disadvantage.attack.all\\\",\\n          \\\"mode\\\": 0,\\n          \\\"value\\\": \\\"1\\\",\\n          \\\"priority\\\": 0\\n        },\\n        {\\n          \\\"key\\\": \\\"flags.midi-qol.disadvantage.ability.check.all\\\",\\n          \\\"mode\\\": 0,\\n          \\\"value\\\": \\\"1\\\",\\n          \\\"priority\\\": 0\\n        }\\n      ],\\n      \\\"description\\\": \\\"<p>- A poisoned creature has disadvantage on attack rolls and ability checks.</p>\\\",\\n      \\\"disabled\\\": false,\\n      \\\"duration\\\": {\\n        \\\"rounds\\\": 2,\\n        \\\"seconds\\\": null,\\n        \\\"turns\\\": null,\\n        \\\"startTime\\\": null,\\n        \\\"combat\\\": null,\\n        \\\"startRound\\\": null,\\n        \\\"startTurn\\\": null\\n      },\\n      \\\"flags\\\": {\\n        \\\"dfreds-convenient-effects\\\": {\\n          \\\"isConvenient\\\": true,\\n          \\\"isDynamic\\\": false,\\n          \\\"isViewable\\\": true,\\n          \\\"nestedEffects\\\": [],\\n          \\\"subEffects\\\": []\\n        },\\n        \\\"dae\\\": {\\n          \\\"stackable\\\": \\\"noneName\\\",\\n          \\\"specialDuration\\\": [\\n            \\\"turnEndSource\\\"\\n          ],\\n          \\\"transfer\\\": false,\\n          \\\"disableIncapacitated\\\": false,\\n          \\\"selfTarget\\\": false,\\n          \\\"selfTargetAlways\\\": false,\\n          \\\"dontApply\\\": false,\\n          \\\"showIcon\\\": false,\\n          \\\"durationExpression\\\": \\\"\\\",\\n          \\\"macroRepeat\\\": \\\"none\\\"\\n        },\\n        \\\"times-up\\\": {\\n          \\\"isPassive\\\": false\\n        },\\n        \\\"ActiveAuras\\\": {\\n          \\\"isAura\\\": false,\\n          \\\"aura\\\": \\\"None\\\",\\n          \\\"nameOverride\\\": \\\"\\\",\\n          \\\"radius\\\": \\\"\\\",\\n          \\\"alignment\\\": \\\"\\\",\\n          \\\"type\\\": \\\"\\\",\\n          \\\"customCheck\\\": \\\"\\\",\\n          \\\"ignoreSelf\\\": false,\\n          \\\"height\\\": false,\\n          \\\"hidden\\\": false,\\n          \\\"displayTemp\\\": false,\\n          \\\"hostile\\\": false,\\n          \\\"onlyOnce\\\": false,\\n          \\\"wallsBlock\\\": \\\"system\\\"\\n        }\\n      },\\n      \\\"icon\\\": \\\"modules/dfreds-convenient-effects/images/poisoned.svg\\\",\\n      \\\"name\\\": \\\"Poisoned\\\",\\n      \\\"origin\\\": \\\"\\\",\\n      \\\"tint\\\": null,\\n      \\\"transfer\\\": false,\\n      \\\"statuses\\\": [\\n        \\\"Convenient Effect: Poisoned\\\",\\n        \\\"poison\\\"\\n      ],\\n      \\\"_id\\\": \\\"okjAiINyCoY5M8Ax\\\"\\n    }\\n  ],\\n    flags: { midiProperties: { nodam: true } },\\n  };\\n}\",\n        \"author\": \"RDUD9VahrEsIwEDB\",\n        \"ownership\": {\n          \"default\": 3\n        },\n        \"_id\": null,\n        \"folder\": null,\n        \"sort\": 0,\n        \"flags\": {},\n        \"_stats\": {\n          \"systemId\": null,\n          \"systemVersion\": null,\n          \"coreVersion\": null,\n          \"createdTime\": null,\n          \"modifiedTime\": null,\n          \"lastModifiedBy\": null\n        }\n      }\n    },\n  },\n \n  };\n}",
        "name": "Poisoner",
        "img": "icons/skills/melee/strike-scythe-fire-green.webp",
        "type": "script",
        "scope": "global",
        "author": "RDUD9VahrEsIwEDB",
        "ownership": {
          "default": 3
        },
        "_id": null,
        "folder": null,
        "sort": 0,
        "flags": {},
        "_stats": {
          "systemId": null,
          "systemVersion": null,
          "coreVersion": null,
          "createdTime": null,
          "modifiedTime": null,
          "lastModifiedBy": null
        }
      }
    },
    "rest-recovery": {
      "data": {
        "recovery": {
          "enabled": false
        }
      }
    },
    "midiProperties": {
      "confirmTargets": "never",
      "autoFailFriendly": false,
      "autoSaveFriendly": false,
      "rollOther": false,
      "critOther": false,
      "offHandWeapon": false,
      "magicdam": false,
      "magiceffect": false,
      "concentration": false,
      "noConcentrationCheck": false,
      "toggleEffect": false,
      "ignoreTotalCover": false
    },
    "midi-qol": {
      "onUseMacroName": "[postActiveEffects]function.MISC.macros.features.poisoner",
      "itemCondition": "",
      "reactionCondition": "",
      "otherCondition": "",
      "effectCondition": "",
      "effectActivation": false,
      "rollAttackPerTarget": "default"
    },
    "exportSource": {
      "world": "basis",
      "system": "dnd5e",
      "coreVersion": "11.315",
      "systemVersion": "2.4.1"
    }
  },
  "img": "icons/skills/melee/strike-scythe-fire-green.webp",
  "effects": [
    {
      "name": "Poisoner",
      "icon": "icons/skills/melee/strike-scythe-fire-green.webp",
      "changes": [
        {
          "key": "flags.midi-qol.onUseMacroName",
          "mode": 0,
          "value": "function.MISC.macros.features.poisoner,preDamageRoll",
          "priority": 20
        },
        {
          "key": "system.tools.pois.prof",
          "mode": 0,
          "value": "1",
          "priority": 20
        }
      ],
      "transfer": true,
      "_id": "Xqi4aPelledv8vUX",
      "disabled": false,
      "duration": {
        "startTime": null,
        "seconds": null,
        "combat": null,
        "rounds": null,
        "turns": null,
        "startRound": null,
        "startTurn": null
      },
      "description": "",
      "origin": "Compendium.midi-item-showcase-community.misc-feats.Item.B4e50qNe0QAnGWLL",
      "statuses": [],
      "flags": {
        "times-up": {
          "isPassive": false
        },
        "dae": {
          "disableIncapacitated": false,
          "selfTarget": false,
          "selfTargetAlways": false,
          "dontApply": false,
          "stackable": "noneName",
          "showIcon": false,
          "durationExpression": "",
          "macroRepeat": "none",
          "specialDuration": []
        },
        "ActiveAuras": {
          "isAura": false,
          "aura": "None",
          "nameOverride": "",
          "radius": "",
          "alignment": "",
          "type": "",
          "customCheck": "",
          "ignoreSelf": false,
          "height": false,
          "hidden": false,
          "displayTemp": false,
          "hostile": false,
          "onlyOnce": false,
          "wallsBlock": "system"
        }
      },
      "tint": null,
      "_key": "!items.effects!B4e50qNe0QAnGWLL.Xqi4aPelledv8vUX"
    }
  ],
  "folder": null,
  "_stats": {
    "systemId": "dnd5e",
    "systemVersion": "3.1.2",
    "coreVersion": "11.315",
    "createdTime": 1701632064698,
    "modifiedTime": 1715296229892,
    "lastModifiedBy": "B2BBHntfpytXE8DP"
  },
  "_id": "B4e50qNe0QAnGWLL",
  "sort": 1000000,
  "ownership": {
    "default": 0,
    "B2BBHntfpytXE8DP": 3
  },
  "_key": "!items!B4e50qNe0QAnGWLL"
}
